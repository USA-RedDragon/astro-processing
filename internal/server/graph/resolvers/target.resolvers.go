package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/USA-RedDragon/astro-processing/internal/server/graph"
	"github.com/USA-RedDragon/astro-processing/internal/server/graph/model"
	"github.com/USA-RedDragon/astro-processing/internal/store/models/targetscheduler"
	"github.com/USA-RedDragon/astro-processing/internal/utils"
)

// Targets is the resolver for the targets field.
func (r *queryResolver) Targets(ctx context.Context) ([]*model.Target, error) {
	db := r.db.WithContext(ctx)
	var targets []targetscheduler.Target
	if err := db.Find(&targets).Error; err != nil {
		return nil, err
	}

	var result []*model.Target
	for _, t := range targets {
		result = append(result, t.GraphQL())
	}
	return result, nil
}

// Target is the resolver for the target field.
func (r *queryResolver) Target(ctx context.Context, id int) (*model.Target, error) {
	db := r.db.WithContext(ctx)
	var target targetscheduler.Target
	if err := db.First(&target, id).Error; err != nil {
		return nil, err
	}
	return target.GraphQL(), nil
}

// Project is the resolver for the project field.
func (r *targetResolver) Project(ctx context.Context, obj *model.Target) (*model.Project, error) {
	db := r.db.WithContext(ctx)
	var project targetscheduler.Project
	if err := db.First(&project, obj.Project.ID).Error; err != nil {
		return nil, err
	}
	return project.GraphQL(), nil
}

// Stats is the resolver for the stats field.
func (r *targetResolver) Stats(ctx context.Context, obj *model.Target) (*model.TargetStats, error) {
	return &model.TargetStats{}, nil
}

// LastImageDate is the resolver for the last_image_date field.
func (r *targetStatsResolver) LastImageDate(ctx context.Context, obj *model.TargetStats) (*int32, error) {
	db := r.db.WithContext(ctx)

	target, err := utils.FindParent[*model.Target](ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find parent target for last image date: %w", err)
	}

	var lastImageDate sql.NullInt64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Where("\"targetId\" = ?", target.ID).
		Select("MAX(acquireddate)").
		Scan(&lastImageDate).Error; err != nil {
		return nil, fmt.Errorf("failed to get last image date: %w", err)
	}
	if lastImageDate.Valid {
		val := int32(lastImageDate.Int64)
		return &val, nil
	}
	return nil, nil
}

// Total is the resolver for the total field.
func (r *targetStatsResolver) Total(ctx context.Context, obj *model.TargetStats) (*model.ImagingStats, error) {
	db := r.db.WithContext(ctx)

	target, err := utils.FindParent[*model.Target](ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find parent target for imaging stats: %w", err)
	}

	var acquiredCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Where("\"targetId\" = ?", target.ID).
		Count(&acquiredCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count acquired images: %w", err)
	}

	var acceptedCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Where("\"targetId\" = ? AND \"gradingStatus\" = ?", target.ID, 1).
		Count(&acceptedCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count accepted images: %w", err)
	}

	var rejectedCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Where("\"targetId\" = ? AND \"gradingStatus\" = ?", target.ID, 2).
		Count(&rejectedCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count rejected images: %w", err)
	}

	var desiredCount int64
	if err := db.Model(&targetscheduler.ExposurePlan{}).
		Where("targetid = ?", target.ID).
		Count(&desiredCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count desired exposures: %w", err)
	}

	return &model.ImagingStats{
		AcceptedImages: int32(acceptedCount),
		AcquiredImages: int32(acquiredCount),
		RejectedImages: int32(rejectedCount),
		DesiredImages:  int32(desiredCount),
	}, nil
}

// Filters is the resolver for the filters field.
func (r *targetStatsResolver) Filters(ctx context.Context, obj *model.TargetStats) ([]*model.TargetFilterStats, error) {
	db := r.db.WithContext(ctx)

	target, err := utils.FindParent[*model.Target](ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find parent target for imaging stats: %w", err)
	}

	type exposureTemplateStats struct {
		ExposureTemplateID int
		FilterName         string
		DefaultExposure    *float64
		Gain               *int
		Offset             *int
		AcquiredCount      int64
		AcceptedCount      int64
		RejectedCount      int64
		DesiredCount       int64
	}

	var templateStats []exposureTemplateStats

	if err := db.Table("acquiredimage as ai").
		Select(`et."Id" as exposure_template_id,
			et.filtername as filter_name,
			et.defaultexposure as exposure_time,
			et.gain,
			et.offset,
			COUNT(*) as acquired_count,
			SUM(CASE WHEN ai."gradingStatus" = 1 THEN 1 ELSE 0 END) as accepted_count,
			SUM(CASE WHEN ai."gradingStatus" = 2 THEN 1 ELSE 0 END) as rejected_count,
			COUNT(ep."Id") as desired_count`).
		Joins("INNER JOIN exposureplan ep ON ai.\"exposureId\" = ep.\"Id\"").
		Joins("INNER JOIN exposuretemplate et ON ep.\"exposureTemplateId\" = et.\"Id\"").
		Where("ai.\"targetId\" = ?", target.ID).
		Group("et.\"Id\", et.filtername, et.defaultexposure, et.gain, et.offset").
		Scan(&templateStats).Error; err != nil {
		return nil, fmt.Errorf("failed to get filter stats: %w", err)
	}

	var stats []*model.TargetFilterStats
	for _, ts := range templateStats {
		var exposureTime *int32
		if ts.DefaultExposure != nil {
			v := int32(*ts.DefaultExposure)
			exposureTime = &v
		}
		var gain *int32
		if ts.Gain != nil {
			v := int32(*ts.Gain)
			gain = &v
		}
		var offset *int32
		if ts.Offset != nil {
			v := int32(*ts.Offset)
			offset = &v
		}
		stats = append(stats, &model.TargetFilterStats{
			FilterName:   ts.FilterName,
			ExposureTime: exposureTime,
			Gain:         gain,
			Offset:       offset,
			Imaging: &model.ImagingStats{
				AcceptedImages: int32(ts.AcceptedCount),
				AcquiredImages: int32(ts.AcquiredCount),
				RejectedImages: int32(ts.RejectedCount),
				DesiredImages:  int32(ts.DesiredCount),
			},
		})
	}
	return stats, nil
}

// Target returns graph.TargetResolver implementation.
func (r *Resolver) Target() graph.TargetResolver { return &targetResolver{r} }

// TargetStats returns graph.TargetStatsResolver implementation.
func (r *Resolver) TargetStats() graph.TargetStatsResolver { return &targetStatsResolver{r} }

type targetResolver struct{ *Resolver }
type targetStatsResolver struct{ *Resolver }
