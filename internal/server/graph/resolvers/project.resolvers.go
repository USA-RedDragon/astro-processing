package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/USA-RedDragon/astro-processing/internal/server/graph"
	"github.com/USA-RedDragon/astro-processing/internal/server/graph/model"
	"github.com/USA-RedDragon/astro-processing/internal/store/models/targetscheduler"
	"github.com/USA-RedDragon/astro-processing/internal/utils"
)

// Targets is the resolver for the targets field.
func (r *projectResolver) Targets(ctx context.Context, obj *model.Project) ([]*model.Target, error) {
	db := r.db.WithContext(ctx)
	var targets []targetscheduler.Target
	if err := db.Where("projectid = ?", obj.ID).Find(&targets).Error; err != nil {
		return nil, err
	}
	var result []*model.Target
	for _, t := range targets {
		result = append(result, t.GraphQL())
	}
	return result, nil
}

// Stats is the resolver for the stats field.
func (r *projectResolver) Stats(ctx context.Context, obj *model.Project) (*model.ProjectStats, error) {
	return &model.ProjectStats{}, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, orderBy *model.ProjectOrderBy) ([]*model.Project, error) {
	db := r.db.WithContext(ctx)

	// Apply ordering if provided
	if orderBy != nil {
		direction := "ASC"
		if orderBy.Direction == model.OrderDirectionDesc {
			direction = "DESC"
		}

		switch orderBy.Field {
		case model.ProjectOrderFieldLastImageDate:
			// Special case: requires subquery
			db = db.Order(fmt.Sprintf(`(
				SELECT MAX(acquireddate) 
				FROM acquiredimage 
				JOIN target ON acquiredimage."targetId" = target."Id" 
				WHERE target.projectid = project."Id"
			) %s NULLS LAST`, direction))
		case model.ProjectOrderFieldProgress:
			// Special case: calculate progress as accepted/desired ratio
			db = db.Order(fmt.Sprintf(`(
				SELECT CASE 
					WHEN COALESCE(SUM(ep.desired), 0) = 0 THEN 0 
					ELSE CAST(
						(SELECT COUNT(*) FROM acquiredimage WHERE "targetId" IN (SELECT "Id" FROM target WHERE projectid = project."Id") AND "gradingStatus" = 1) 
						AS FLOAT
					) / COALESCE(SUM(ep.desired), 1)
				END
				FROM target t
				JOIN exposureplan ep ON ep.targetid = t."Id"
				WHERE t.projectid = project."Id"
			) %s NULLS LAST`, direction))
		case model.ProjectOrderFieldName:
			db = db.Order(fmt.Sprintf("name %s", direction))
		case model.ProjectOrderFieldState:
			db = db.Order(fmt.Sprintf("state %s", direction))
		case model.ProjectOrderFieldPriority:
			db = db.Order(fmt.Sprintf("priority %s", direction))
		case model.ProjectOrderFieldCreateDate:
			db = db.Order(fmt.Sprintf("createdate %s NULLS LAST", direction))
		case model.ProjectOrderFieldActiveDate:
			db = db.Order(fmt.Sprintf("activedate %s NULLS LAST", direction))
		case model.ProjectOrderFieldMosaic:
			db = db.Order(fmt.Sprintf("\"isMosaic\" %s", direction))
		}
	}

	var projects []targetscheduler.Project
	if err := db.Find(&projects).Error; err != nil {
		return nil, err
	}

	var result []*model.Project
	for _, p := range projects {
		result = append(result, p.GraphQL())
	}
	return result, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id int) (*model.Project, error) {
	db := r.db.WithContext(ctx)
	var project targetscheduler.Project
	if err := db.First(&project, id).Error; err != nil {
		return nil, err
	}
	return project.GraphQL(), nil
}

// Imaging is the resolver for the imaging field.
func (r *projectStatsResolver) Imaging(ctx context.Context, obj *model.ProjectStats) (*model.ImagingStats, error) {
	db := r.db.WithContext(ctx)
	project, err := utils.FindParent[*model.Project](ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find parent project for last image date: %w", err)
	}

	var acquiredCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Joins("JOIN target ON acquiredimage.\"targetId\" = target.\"Id\"").
		Where("target.projectid = ?", project.ID).
		Count(&acquiredCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count acquired images: %w", err)
	}

	var acceptedCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Joins("JOIN target ON acquiredimage.\"targetId\" = target.\"Id\"").
		Where("target.projectid = ? AND acquiredimage.\"gradingStatus\" = ?", project.ID, 1).
		Count(&acceptedCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count accepted images: %w", err)
	}

	var rejectedCount int64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Joins("JOIN target ON acquiredimage.\"targetId\" = target.\"Id\"").
		Where("target.projectid = ? AND acquiredimage.\"gradingStatus\" = ?", project.ID, 2).
		Count(&rejectedCount).Error; err != nil {
		return nil, fmt.Errorf("failed to count rejected images: %w", err)
	}

	var desiredSum int
	if err := db.Model(&targetscheduler.ExposurePlan{}).
		Joins("JOIN target ON exposureplan.targetid = target.\"Id\"").
		Where("target.projectid = ?", project.ID).
		Select("COALESCE(SUM(exposureplan.desired), 0)").
		Scan(&desiredSum).Error; err != nil {
		return nil, fmt.Errorf("failed to sum desired images: %w", err)
	}

	return &model.ImagingStats{
		AcquiredImages: int32(acquiredCount),
		AcceptedImages: int32(acceptedCount),
		RejectedImages: int32(rejectedCount),
		DesiredImages:  int32(desiredSum),
	}, nil
}

// LastImageDate is the resolver for the last_image_date field.
func (r *projectStatsResolver) LastImageDate(ctx context.Context, obj *model.ProjectStats) (*int32, error) {
	db := r.db.WithContext(ctx)
	project, err := utils.FindParent[*model.Project](ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find parent project for last image date: %w", err)
	}

	var lastImageDate sql.NullInt64
	if err := db.Model(&targetscheduler.AcquiredImage{}).
		Joins("JOIN target ON acquiredimage.\"targetId\" = target.\"Id\"").
		Where("target.projectid = ?", project.ID).
		Select("MAX(acquireddate)").
		Scan(&lastImageDate).Error; err != nil {
		return nil, err
	}
	if lastImageDate.Valid {
		val := int32(lastImageDate.Int64)
		return &val, nil
	}
	return nil, nil
}

// Project returns graph.ProjectResolver implementation.
func (r *Resolver) Project() graph.ProjectResolver { return &projectResolver{r} }

// ProjectStats returns graph.ProjectStatsResolver implementation.
func (r *Resolver) ProjectStats() graph.ProjectStatsResolver { return &projectStatsResolver{r} }

type projectResolver struct{ *Resolver }
type projectStatsResolver struct{ *Resolver }
